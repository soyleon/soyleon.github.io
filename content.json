{"pages":[],"posts":[{"title":"学习笔记","text":"Python 数据结构对于一直是个小白的我，羡慕大佬，在这个接近而立之年，学一学新的知识，代码与数据结构是分不开的，虽然学了N多的语言基础，也写了一些基础的逻辑代码，连一个GOOGLE程序员都算不上，可能只能当作百度程序员了。 写程序最大的问题就是不能坚持，坚持做一件事情才能真正的可以掌握技术。 此笔记是根据在油管上的数据结构python教程而作传智播客Python就业班) 第一天Python 列表类型的不同操作的时间效率Python中不同的列表可以用不同的操作向列表内部添加元素。不同的操作的时间效率是不同的。这里对不同的操作的时间效率进行比对 123456789101112131415161718192021222324252627282930313233343536373839404142434445import timeitdef test1(): li = [] for i in range(10000): li += [i]def test2(): li = [] for i in range(10000): li.append(i)def test3(): li = [i for i in range(10000)]def test4(): li = list(range(10000))def test5(): li = [] for i in range(10000): li.extend([i])def test6(): li = [] for i in range(10000): li.insert(0,1)timer1 = timeit.Timer(&quot;test1()&quot;, &quot;from __main__ import test1&quot;)print(&quot;+:&quot;, timer1.timeit(1000))timer2 = timeit.Timer(&quot;test2()&quot;, &quot;from __main__ import test2&quot;)print(&quot;append:&quot;, timer2.timeit(1000))timer3 = timeit.Timer(&quot;test3()&quot;, &quot;from __main__ import test3&quot;)print(&quot;[i for i in range]:&quot;, timer3.timeit(1000))timer4 = timeit.Timer(&quot;test4()&quot;, &quot;from __main__ import test4&quot;)print(&quot;list(range())&quot;, timer4.timeit(1000))timer5 = timeit.Timer(&quot;test5()&quot;, &quot;from __main__ import test5&quot;)print(&quot;extend&quot;, timer5.timeit(1000))timer6 = timeit.Timer(&quot;test6()&quot;, &quot;from __main__ import test6&quot;)print(&quot;insert(0)&quot;, timer6.timeit(1000)) timeit是用来计算程序运行时间的包 Operation Big-O Efficiency index x[] O(1) #取值 index assignment O(1) #赋值 append O(1) #尾部追加 pop() O(1) #不加参数就是从尾部往外取 pop(i) O(n) #从指定位置往外弹(最坏情况，从第一个往外弹) insert(i,item) O(n) #在指定位置插入元素 del operator O(n) #删除 iteration O(n) #迭代 get slice[x:y] O(k) #和x,y之间的距离有关系 del slice O(n) #删除切片，后面的会往前移 set slice O(n+k) #先加后补充 reverse O(n) #倒置 concatenate O(k) #把第二个列表的东西补充进来 sort O(nlogn) #与具体排序的算法有关 multiply O(nk) #乘的是k,列表里的个数是n 第二天字典不同操作的时间复杂度 Operation Big-O Efficiency copy O(n) get item O(1) set item O(1) delete item O(1) contains(in) O(1) iteration O(n) 数据结构引入假设想要存储学生的信息，存储：name, age, hometown，有几种方法？ 列表中包括元组： 12345[ (&quot;zhangsan&quot;, 24, &quot;beijing&quot;), (&quot;zhangsan&quot;, 24, &quot;beijing&quot;), (&quot;zhangsan&quot;, 24, &quot;beijing&quot;),] 列表中包含字典 1234567[ { &quot;name&quot;：&quot;zhangsan&quot;, &quot;age&quot;:&quot;24&quot;, &quot;hometown&quot;:&quot;beijing&quot; }] 字典中包含字典 123456{ &quot;zhangsan&quot;:{ &quot;age&quot;:&quot;24&quot;, &quot;hometown&quot;:&quot;beijing&quot; }} 数据：基本的数据类型， 如 int, float, char等。是一个个的数据元素。 数据结构：基本数据类型的封装，只是静态的描述了数据元素之间的关系。 程序 = 数据结构 + 算法 算法这是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体 抽象数据类型（Abstract Data Type）抽象数据类型( ADT )：一个数学模型以及定义在此数学模型上的一组操作，即把数据类型和数据类型的运算捆绑在一起进行分装。引入抽象数据类型的目的是把数据类型的表示和数据类型上的运算的实现与这些数据类型和运算在程序中的引用隔开，使他们相互独立。 123456class Stus(object): def adds(self): def pop(self): def sort(self): def modify(self):&quot;&quot;&quot;增删改差&quot;&quot;&quot; 最常用的数据运算： 插入 删除 修改 查找 排序 第三天类型，内存，及顺序表 第四天基本数据表与元素外围顺序表基本数据类型 12345int = 1,2,3,4,5li = a 0x01 00000000 0x02 00000000 0x03 00000000 0x04 00000001 顺序表的一体式结构与分离式结构顺序表的两种基本实现方式：一体式结构，分离式结构 max num 元素存储区 8 4 a 一体式结构 python列表的表现List 行为特征 基于下标（位置）的高效元素访问和更新，时间复杂度应该是O(1)。 为满足该特征，应该采用顺序表技术，表中元素保存在一块连续的存储区中。 允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（函数ID得到的值）不变。 为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识ID不变，只能采用分离式实现技术， 栈堆栈，是一种容器，可存入数据元素，访问元素 ，删除元素，它的特点在于只能允许在容器的一段（栈顶端指标）进行加入数据（push）和输出数据（pop）的运算。没有了位置概念，保证任何时候可以访问，删除的元素都是此前存入的那个元素，确定了一种默认的访问顺序。 栈 由于栈数据只允许在一端进行操作，因而按照后进先出（LIFO, Last in First Out）的原理运作。 队列队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。队列是一种先进先出的(First In First Out)的线性表，简称FIFO。允许插入的一端为队尾，允许删除的一端为队头。队列不循序在中间部位进行操作。假设队列q=(a1,a2,......,an)，那么a1 就是队头元素，而an 是队尾元素。这样我们就可以删除时，总是在队列最后。这也比较符合我们通常生活中的习惯，排在第一个优先出列，最后来的当然排在队伍最后。 第四天栈的实现借用LIST实现栈 栈的操作： Stack() 创建一个新的空栈 push(item) 添加一个新的元素item到栈顶 pop()弹出栈顶元素 peek() 返回栈顶元素 is_empty() 判断栈是否为空 size返回栈的元素个数 123456789101112131415161718192021222324252627282930class stack(object): &quot;&quot;&quot;栈&quot;&quot;&quot; def __init__(self): self.__list = [] def push(self, item): &quot;&quot;&quot;添加一个新的元素item到栈顶&quot;&quot;&quot; self.__list.append(item) def pop(self): &quot;&quot;&quot;弹出栈顶元素&quot;&quot;&quot; return self.__list.pop() def peek(self): &quot;&quot;&quot;返回栈顶元素&quot;&quot;&quot; if self.__list: return self.__listp[-1] else: return None def is_empty(self): &quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot; return self.__list == [] def size(self): &quot;&quot;&quot;返回栈的元素个数&quot;&quot;&quot; return len(self.__list) if __name__ == &quot;__main__&quot;: s = Stack() 队列的实现 队列：取数据的端是队头，添加的一端是队尾 12345678910111213141516class Queue[object]: &quot;&quot;&quot;队列&quot;&quot;&quot; def __init__(self): self.__list = [] def enqueue(self, item): &quot;&quot;&quot;在队列中添加一个item元素&quot;&quot;&quot; self.__list.append(item) def dequeue(self): &quot;&quot;&quot;从队列头部删除一个元素&quot;&quot;&quot; return self.__list.pop(0) def is_empty(self): &quot;&quot;&quot;判断一个队列是否为空&quot;&quot;&quot; return self.__list == [] def size(self): &quot;&quot;&quot;返回队列的大小&quot;&quot;&quot; return len(self.__list) 双端队列双端队列，是一种具有队列和栈的性质的数据结构。 双端队列的元素可以从两端弹出，其限定插入和操作在表的两端进行，双端队列可以在队列的任意一端入队和出队。 操作 Deque()创建一个空的双端队列 add_front(item)从队头加入一个item元素 add_rear(item)从队尾加入一个item元素 remove_front()从队头删除一个item元素 remove_rare()从队尾删除一个item元素 is_empty() 判断双端队列是否为空 size() 返回队列的大小 第五天链表每一个存入的数据与下一个存入的数据的地址相连接，通过这个连线不断的连接新加入的元素。 链表与顺序表统称线性表 单向链表：单向表，它的每个节点包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。 单链表 将一个节点扩展成两个位置，第一个位置保存数据（数据区），第二个位置保存地址（链接区）。 单向链表单向链表的线是单方向的。 表元素域elem用来存放具体的数据 链接域next用来存放下一个节点的位置（python中的标识） 变量p指向链表的头节点（首节点）的位置，从p出发能找到表中的任意节点。 123456class SingleNode(object): &quot;&quot;&quot;单链表的结点&quot;&quot;&quot; def __init__(self,item): def __init__(self): self.item = item self.next = None 单链表的操作 is_empty() 链表是否为空 length()链表长度 travel()遍历整个链表 add(item)链表头部添加元素 append(item)链表尾部添加元素 insert（pos, item)指定位置添加元素 remove(item) remove(item) 删除节点 search(item)查找结点是否存在 第六天单链表的实现 单链表及节点的定义代码 单链表的判空，长度，遍历与尾部添加结点的代码实现 单链表尾部添加和在指定位置添加 单链表查找和删除元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120class Node(object): &quot;&quot;&quot;单链表的结点&quot;&quot;&quot; def __init__(self, elem): self.elem = elem self.next = None passclass SingleLinkList(object): &quot;&quot;&quot;单链表&quot;&quot;&quot; def __init__(self, node=None): self.__head = node def is_empty(self): &quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot; return self.__head == None def length(self): &quot;&quot;&quot;返回链表长度&quot;&quot;&quot; cur = self.__head count = 0 while cur != None: count += 1 cur = cur.next return count def travel(self): &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot; cur = self.__head while cur != None: print(cur.elem, end=&quot; &quot;) cur = cur.next print() def add(self, item): &quot;&quot;&quot;链表头部增加元素，头插法&quot;&quot;&quot; node = Node(item) node.next = self.__head self.__head = node def append(self, item): &quot;&quot;&quot;链表尾部增加元素,尾插法&quot;&quot;&quot; node = Node(item) if self.is_empty(): self.__head = node else: cur = self.__head while cur.next != None: cur = cur.next cur.next = node def insert(self, pos, item): &quot;&quot;&quot;制定位置添加元素 : para : pos 从0开始 &quot;&quot;&quot; if pos &lt; 0: self.add(item) elif pos &gt; (self.length()-1): self.append(item) else: pre = self.__head count = 0 node = Node(item) while count &lt; pos-1: pre = pre.next count += 1 node.next = pre.next pre.next = node def remove(self, item): &quot;&quot;&quot;删除节点&quot;&quot;&quot; if self.is_empty(): return self else: pre = self.__head if pre.elem == item: self.__head = pre.next else: while pre.next != None : if pre.next.elem == item: pre.next = pre.next.next else: pre = pre.next def search(self, item): &quot;&quot;&quot;查找结点是否存在&quot;&quot;&quot; cur = self.__head while (cur != None): if cur.elem == item: return True cur = cur.next return Falseif __name__ == &quot;__main__&quot;: ll = SingleLinkList() print(ll.search(1)) print(ll.is_empty()) print(ll.length()) ll.append(1) print(ll.is_empty()) print(ll.length()) ll.append(2) ll.add(8) ll.append(3) ll.append(4) ll.append(5) ll.append(6) ll.insert(-1, 9) ll.insert(3, 100) ll.insert(10, 200) ll.append(100) ll.append(100) ll.travel() ll.remove(9) ll.travel() ll.remove(100) ll.travel() 链表与顺序表的对比 链表只记录头节点，并且时间复杂度比顺序表高，但是，链表在存储数据时，对于存储空间的自由度会更高，与此同时，它占有了更多的内存来存储节点的指针域。对于插入操作，链表的插入只是在于遍历。多余顺序表主要花费在处理存储空间。 第七天单向循环链表和普通的单向链表唯一的区别在于最后的next区域指向了头节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159class Node(object): &quot;&quot;&quot;单链表的结点&quot;&quot;&quot; def __init__(self, elem): self.elem = elem self.next = None passclass SingleCycleLinkList(object): &quot;&quot;&quot;单链表&quot;&quot;&quot; def __init__(self, node=None): self.__head = node if node: node.next = node def is_empty(self): &quot;&quot;&quot;判断链表是否为空&quot;&quot;&quot; return self.__head == None def length(self): &quot;&quot;&quot;返回链表长度&quot;&quot;&quot; cur = self.__head if cur == None: count = 0 else: count = 1 while cur.next != self.__head: # 对于单向循环链表只能存在一种判别 count += 1 cur = cur.next return count def travel(self): &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot; cur = self.__head if cur == None: print(&quot;None&quot;) else: while cur.next != self.__head: print(cur.elem, end=&quot; &quot;) cur = cur.next print(cur.elem) def add(self, item): &quot;&quot;&quot;链表头部增加元素，头插法&quot;&quot;&quot; cur = self.__head node = Node(item) if cur == None: self.__head = node node.next = node else: while cur.next != self.__head: cur = cur.next node.next = self.__head self.__head = node cur.next = node def append(self, item): &quot;&quot;&quot;链表尾部增加元素,尾插法&quot;&quot;&quot; node = Node(item) if self.is_empty(): self.__head = node node.next = node else: cur = self.__head while cur.next != self.__head: cur = cur.next node.next = self.__head cur.next = node def insert(self, pos, item): &quot;&quot;&quot;制定位置添加元素 : para : pos 从0开始 &quot;&quot;&quot; if pos &lt; 0: self.add(item) elif pos &gt; (self.length()-1): self.append(item) else: pre = self.__head count = 0 node = Node(item) while count &lt; pos-1: pre = pre.next count += 1 node.next = pre.next pre.next = node def remove(self, item): &quot;&quot;&quot;删除节点&quot;&quot;&quot; if self.is_empty(): return None else: pre = self.__head if pre.elem == item: if pre.next == self.__head: self.__head = None else: rear = self.__head while rear.next != self.__head: rear = rear.next self.__head = pre.next rear.next = self.__head else: while pre.next != self.__head: if pre.next.elem == item: pre.next = pre.next.next else: pre = pre.next def search(self, item): &quot;&quot;&quot;查找结点是否存在&quot;&quot;&quot; if self.is_empty(): return False cur = self.__head while cur.next != self.__head: if cur.elem == item: return True else: cur = cur.next if cur.elem == item: return True return Falseif __name__ == &quot;__main__&quot;: ll = SingleCycleLinkList() ll.add(1) ll.add(2) ll.travel() ll.remove(2) ll.travel() print(ll.search(1)) print(ll.is_empty()) print(ll.length()) ll.append(1) print(ll.is_empty()) print(ll.length()) ll.append(2) ll.add(8) ll.append(3) ll.append(4) ll.append(5) ll.append(6) ll.insert(-1, 9) ll.insert(3, 100) ll.insert(10, 200) ll.append(100) ll.append(100) ll.travel() ll.remove(9) ll.travel() ll.remove(100) ll.travel() 在单向循环链表中，不同的地方在于边界条件，对于单链表，我们既可以通过判断 cur.next ,同样可以通过判断cur这个变量，而在单向循环链表中，只有cur.next可以使用来判断边界条件，因此根据此，需要在边界条件外继续添加最后一项的结果。最大的区别在于remove()函数 第一项判断，当第一项为唯一的项并却被删除后，链表为空。当不是唯一的项时，需要将最后一项的next指向新的第一项。 第八天双向链表及添加元素双向链表是一种更复杂的链表，每一个链表有两个链接，一个指向前一个节点，当此节点为第一个节点时，指向空值；而另一个指向下一个节点，当此节点为最后一个节点时，只想空值。 操作： is_empty() 链表是否为空 length() 链表长度 travel() 遍历链表 add(item) 链表头部添加 append(item) 链表尾部添加 insert(pos, item) 指定位置添加 remove(item) 删除节点 search(item) 查找节点是否存在 第九天冒泡排序 分别将最大的值放在最后，冒泡的意思就是在一次循环中找到最大的值 123456789101112131415def bubble_sort(alist): for j in range(len(alist)-1): count = 0 for i in range(len(alist)-j-1): if alist[i] &gt; alist[i+1]: alist[i], alist[i+1] = alist[i+1], alist[i] count = count+1 if count == 0: breakif __name__ == &quot;__main__&quot;: a_list = [1, 2, 1, 2, 1, 2] bubble_sort(a_list) print(a_list) 优化，加上count之后，当序列已经是有序的之后，跳出循环，不需要再进行循环浪费资源。 选择排序 1234567891011121314def selection_sort(alist): n = len(alist) for j in range(n-1): max_index = 0 for i in range(n-j): if alist[i] &gt;= alist[max_index]: max_index = i alist[n-j-1], alist[max_index] = alist[max_index], alist[n-j-1]if __name__ == &quot;__main__&quot;: a_list = [1, 2, 3, 77, 5, 99, 3, 7] selection_sort(a_list) print(a_list) 这时候要保持算法的稳定性需要将判定条件改变一下，将&gt;改成&gt;=，这样在后面的值仍然保持在后面，而在前面的值仍然保持在前面。 第十天插入排序插入排序将第一项作为有序序列，后方作为无序状态，将后方的无序的数据不断的插入前方的有序数据中它理应所在的位置，达到排序的效果 1234567891011121314def insertion_sort(alist): n = len(alist) for i in range(1, n): for j in range(i, 0, -1): # range函数包括前值，不包括后值 if alist[j] &lt; alist[j-1]: alist[j], alist[j-1] = alist[j-1], alist[j] else: breakif __name__ == &quot;__main__&quot;: a_list = [10, 4, 3, 77, 5, 99, 3, 1] insertion_sort(a_list) print(a_list) 希尔排序希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 1234567891011121314151617181920212223&quot;&quot;&quot;希尔排序&quot;&quot;&quot;def shell_sort(alist): n = len(alist) gap_len = n // 2 while gap_len &gt; 0: for j in range(gap_len, n): for k in range(j, gap_len, -gap_len): if alist[k] &lt; alist[k-gap_len]: alist[k], alist[k-gap_len] = alist[k-gap_len], alist[k] else: break gap_len = gap_len//2if __name__ == &quot;__main__&quot;: a_list = [1, 2, 3, 77, 5, 99, 3, 7, 11] shell_sort(a_list) print(a_list) 希尔排序是一个很强大的工具，一开始开始写的时候只是简单的根据算法描述的循环，i 从1-gap_len先循环一边，这个其实就是一种个非常耗费时间的算法，虽然可以实现，但是对于大规模的数据，它的速度可能会达到O(N^3)，看了网上的代码，都是沿用了如上的代码，这里我们把前面从1-gap-len这一部分本身当作第一个部分，是一个有序的部分，从后面的数据开始循环，同样可以达到效果。","link":"/2020/06/13/learning%20log/"},{"title":"My Gallery","text":"","link":"/2020/06/14/My-Gallery/"},{"title":"20200616菜鸡的日子","text":"不想写代码于2020年6月16日记 又是一天不想写代码，这时候很希望身边有个前辈大牛来分享如何解决自己什么都不想写的问题。或者说不知道写什么，看着gayhub上别人写的代码，是抄呢还是怎么，一点头绪都没有。 好奇别人都是怎么给自己找项目做的，自己一个人这么搞是真的头疼。每天下午下班之后安排了这些时间来做一些自己喜欢，好玩的事情。确实自己对这个不反感，而且也很喜欢这种不断在思考，思考这段代码为什么要这么写，思考这个算法怎么这么神奇，然而自己只能做到copy，然后觉得自己真的是笨。 当然也是懊悔自己在大学的时候怎么浪费那么一大把的时间，在那个时候有图书馆可以借鉴任何的书，并且都是带着纸香味的宝藏，现在只能对着屏幕看这些。效果真的差了很多。 每天在看数据结构与算法分析的C语言版，然而自己的C语言还停留在大一听的C语言课，水平可能还远不如那时候，毕竟那时候自己还能尝试着写出来小游戏，现在可以熟练的使用pygame. 最后还是给自己点正能量吧，自勉。慢慢读慢慢写吧，希望自己可以成为一个正常的码农，不用当个大牛，不用造轮子，自己满足就行。 卖杂货的码农","link":"/2020/06/16/20200616%E8%8F%9C%E9%B8%A1%E7%9A%84%E6%97%A5%E5%AD%90/"},{"title":"新建DJANGO的坑","text":"Pycharm新建DJANGO的坑莫名其妙的遇到了一个坑，本来以为是很简单的一件事情，然而就因为这个坑耽误了很长时间。 首先现在github上新建了仓库（虽然我也不知道我为什么会现在远程建立仓库，完全可以在本地建立完然后上传到远程仓库，这样会简单很多），然后将github初始化的文件clone到自己的本地仓库。然而，因为我想将这个空仓库新建一个Django的项目，于是打开Pycharm,打开这个什么都没有的文件，选择files,如下图 ![](\\新建DJANGO的坑/pycharm_file.jpg) 然后打开project interpreter安装Django.然而这时候就发现一件非常坑的事情。Django的manage.py文件没有了。。。 为了解决这个问题，我只能新建一个DJANGO项目，这个是pycharm中很基础的问题，直接新建项目选择Django就可以，这时候就是正常的项目：这样就正常出来了。然后下面是正常的git操作。 1234567git initgit remote addgit pull git mergegit addgit commitgit push all is done 菜鸡的挣扎之旅","link":"/2020/06/18/%E6%96%B0%E5%BB%BADJANGO%E7%9A%84%E5%9D%91/"}],"tags":[{"name":"DataStruct","slug":"DataStruct","link":"/tags/DataStruct/"},{"name":"diary","slug":"diary","link":"/tags/diary/"},{"name":"DJANGO Learning","slug":"DJANGO-Learning","link":"/tags/DJANGO-Learning/"}],"categories":[{"name":"LifeStyle","slug":"LifeStyle","link":"/categories/LifeStyle/"},{"name":"Technology","slug":"Technology","link":"/categories/Technology/"}]}